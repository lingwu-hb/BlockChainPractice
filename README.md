# BlockChainPractice
Dian_BlockChainPractice
## 日志

### 10/1

#### 区块链的应用

根据区块链中存储的信息的不同，区块链所应用的场所也不尽相同。（比如比特币中所应用的区块中就是存储的用户交易信息）

例如：建立食物链。

#### 区块链网络类型

分为四种类型：公有区块链、私有区块链、联盟区块链、许可区块链。

主要研究共有区块链技术，另外三种只是部分不同，大体一致。

由于Go语言支持语言层次上的并发操作，所以Go语言非常适合分布式系统（可以简单理解为具有很多个服务器的一个集成系统）

#### Go语言包的管理机制

* 包

包是一系列源代码的集合。每个源文件都要求属于且仅属于一个包。

按照道理说，每个Go语言应用程序都有一个main包，main包中能有一个main方法。但是本次实习为了方便，将所有的.go文件都放到同一个main包中，然后编译运行时，只需要分开单独编译运行即可。

* GOPATH模式

GOPATH模式最大的问题就是版本管理，GOPATH模式根本就没有版本的概念。导入包时，无法确保导入最新的版本，因为所有的版本都是一样的命名。

* GO vender 模式

每个Go项目都有一个独立的vender文件夹，可以在文件夹中存放一些包（自己写的或者导入的外部包）。每个项目的vender之间互相不影响。

问题：如果有很多的Go项目都使用了同一个包，那么就会导致在很多地方都需要导入同一个包，这无疑是对磁盘空间的一种浪费。除此之外，也无法对第三方包进行集中的管理。

* GO mod模式

通过一下命令来打开GO mod模式（将环境变量GO111MODULE修改为on）

```shell
$ go env -w GO111MODULE="on"
```

比较复杂，主要是通过go.mod和go.sum两个文件夹来实现。（以后再深入了解）

#### PoW算法简单实现

* PoW算法简述：

PoW，全称为Proof of Work（工作量证明）。由于哈希算法的单向性，计算机只能通过枚举的方式不断尝试。只有运用巨大的算力率先得到满足难度值答案的用户，才算完成了工作量证明，从而有权利进行打包交易，并活得手续费。

* 实现PoW算法

创世区块中难度值为1（也就是前32位为零）

![image-20211001144935563](C:\Users\lingwu\AppData\Roaming\Typora\typora-user-images\image-20211001144935563.png)

#### PoS算法

* PoS算法简介：

权益证明，也就是说谁的权益（持币数乘以持币时间）更大，谁就更有可能称为矿工，进行打包。

* 实现原理：

PoS实现的重点是如何用数据表示出权益值，暂时先忽略时间因素，只考虑持币数。设定一个切片，切片长度等于总币数，切片的值为该比特币的用户地址。（即该切片表示了每一个比特币的拥有者是谁）然后再数组内产生随机数，实现简易版本的PoS算法。

### 10/2

预期完成任务：

1）学习使用GO MOD模式（记得仔细阅读一下官方教程）

2）实现PoS简易算法（写道一个新的go文件中，但是记得先搞清楚go语言多文件的一些规则）

3）开始动手进阶任务

#### PoS算法简易实现

源代码文件放在project01_demo\main\PoS.go中。

关键是如何利用矿工的权益值，通过随机数选出一个幸运矿工。

下面的函数解决了这个问题。

将所有用户的权益比例计算出来后，然后依次存到[0, 1] 之间。再利用随机数产生一个0到1之间的小数，看该小数落到哪一块，哪一位用户就有权力打包。

```go
// ReturnIndex 利用随机数返回一个幸运矿工的序号
func ReturnIndex(users []User) int64 {
	for _, user := range users {
		user.ComputeWeight() //为每一个用户计算权益值
	}
	//随机数算法返回幸运的打包者
	//计算总权重
	var totalWeight int64
	for i := 1; i <= userNum; i++ {
		totalWeight += users[i].weight
	}
	var portion []float64 = make([]float64, userNum) //记录每个用户的比例（portion）
	for i := 1; i <= userNum; i++ {
		// 将每个用户所占的比例计算出来，然后再加上之前的用户的比例（最终所有用户的比例会占满[0, 1]）
		portion[i] = float64(users[i].weight)/float64(totalWeight) + portion[i-1]
	}
	rand.Seed(time.Now().Unix())
	var x = rand.Float64()
	for i := 1; i <= userNum; i++ {
		if x > portion[i-1] && x < portion[i] {
			return int64(i)
		}
	}
	return 0
}
```

